#!/usr/bin/env python3
"""
Skill: vulnerability-scanner
Script: dependency_analyzer.py
Purpose: Analyze dependency health and lockfile integrity.
Usage: python dependency_analyzer.py <project_path>
Output: JSON summary
"""

from __future__ import annotations

import json
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List


def detect_lockfiles(project_path: Path) -> Dict[str, bool]:
    return {
        "npm": (project_path / "package-lock.json").exists() or (project_path / "npm-shrinkwrap.json").exists(),
        "yarn": (project_path / "yarn.lock").exists(),
        "pnpm": (project_path / "pnpm-lock.yaml").exists(),
        "python": (project_path / "requirements.txt").exists()
        or (project_path / "poetry.lock").exists()
        or (project_path / "Pipfile.lock").exists(),
    }


def run_npm_audit(project_path: Path) -> Dict[str, Any]:
    if not (project_path / "package.json").exists():
        return {"enabled": False, "reason": "package.json not found"}

    candidates = [["npm", "audit", "--json"], ["npm.cmd", "audit", "--json"]]
    proc = None
    last_error = None

    for cmd in candidates:
        try:
            proc = subprocess.run(
                cmd,
                cwd=str(project_path),
                capture_output=True,
                text=True,
                timeout=120,
            )
            break
        except FileNotFoundError as exc:
            last_error = exc
            continue
        except subprocess.TimeoutExpired:
            return {"enabled": False, "reason": "npm audit timed out"}

    if proc is None:
        return {"enabled": False, "reason": "npm not installed", "detail": str(last_error) if last_error else ""}

    payload: Dict[str, Any] = {}
    try:
        payload = json.loads(proc.stdout or "{}")
    except json.JSONDecodeError:
        return {
            "enabled": True,
            "ok": False,
            "reason": "invalid npm audit JSON output",
            "stderr": (proc.stderr or "")[:300],
        }

    counts = {"critical": 0, "high": 0, "moderate": 0, "low": 0}
    vulnerabilities = payload.get("vulnerabilities", {})
    for vuln in vulnerabilities.values():
        severity = str(vuln.get("severity", "")).lower()
        if severity in counts:
            counts[severity] += 1

    return {
        "enabled": True,
        "ok": proc.returncode == 0,
        "returncode": proc.returncode,
        "counts": counts,
    }


def analyze(project_path: Path) -> Dict[str, Any]:
    lockfiles = detect_lockfiles(project_path)
    npm_audit = run_npm_audit(project_path)

    findings: List[Dict[str, str]] = []
    if (project_path / "package.json").exists() and not (lockfiles["npm"] or lockfiles["yarn"] or lockfiles["pnpm"]):
        findings.append(
            {
                "severity": "high",
                "type": "lockfile",
                "message": "No JavaScript lockfile detected (package-lock/yarn.lock/pnpm-lock.yaml).",
            }
        )

    critical_count = 0
    if npm_audit.get("enabled") and npm_audit.get("counts"):
        critical_count = int(npm_audit["counts"].get("critical", 0))
        high_count = int(npm_audit["counts"].get("high", 0))
        if critical_count > 0:
            findings.append(
                {
                    "severity": "critical",
                    "type": "npm-audit",
                    "message": f"npm audit found {critical_count} critical vulnerabilities.",
                }
            )
        elif high_count > 0:
            findings.append(
                {
                    "severity": "high",
                    "type": "npm-audit",
                    "message": f"npm audit found {high_count} high vulnerabilities.",
                }
            )

    status = "[OK] dependency health looks good"
    if any(f["severity"] == "critical" for f in findings):
        status = "[!!] critical dependency issues detected"
    elif findings:
        status = "[!] dependency issues detected"

    return {
        "project": str(project_path),
        "status": status,
        "lockfiles": lockfiles,
        "npm_audit": npm_audit,
        "findings": findings,
        "recommendations": [
            "Keep lockfiles committed for reproducible installs.",
            "Run `npm audit fix` for non-breaking updates.",
            "Review critical advisories manually before deployment.",
        ],
    }


def main() -> int:
    if len(sys.argv) < 2:
        print(json.dumps({"error": "Usage: python dependency_analyzer.py <project_path>"}))
        return 1

    project_path = Path(sys.argv[1]).resolve()
    if not project_path.exists():
        print(json.dumps({"error": f"Project path does not exist: {project_path}"}))
        return 1

    result = analyze(project_path)
    print(json.dumps(result, indent=2))

    # Fail only on critical dependency findings.
    has_critical = any(f.get("severity") == "critical" for f in result.get("findings", []))
    return 1 if has_critical else 0


if __name__ == "__main__":
    raise SystemExit(main())
